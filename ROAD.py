# Документация Проекта QIKI Simulation

**Версия:** 1.0
**Дата:** 26 июля 2024 г.

## Содержание
1.  [Обзор Проекта](#1-обзор-проекта)
    1.1. [Введение](#11-введение)
    1.2. [Цели и Задачи](#12-цели-и-задачи)
    1.3. [Ключевые Возможности](#13-ключевые-возможности)
2.  [Архитектура Системы](#2-архитектура-системы)
    2.1. [Высокоуровневая Архитектура](#21-высокоуровневая-архитектура)
    2.2. [Обзор Основных Компонентов](#22-обзор-основных-компонентов)
    2.3. [Потоки Данных (Концептуально)](#23-потоки-данных-концептуально)
3.  [Справочник по Модулям](#3-справочник-по-модулям)
    3.1. [`main.py` - Ядро Симуляции](#31-mainpy---ядро-симуляции)
    3.2. `config.py` - Конфигурация
    3.3. `logger.py` - Система Логирования
    3.4. `physics.py` - Физический Движок
    3.5. `hardware/` - Слой Аппаратной Абстракции
    3.6. `environment.py` - Среда Симуляции
    3.7. `sensors.py` - Агрегация Данных Сенсоров
    3.8. `agent.py` - Принятие Решений ИИ
    3.9. `qik_os.py` - Операционная Система QIKI
    3.10. `bot_interface_impl.py` - Интерфейс Бота для QikOS
    3.11. `visualizer.py` - Графический Визуализатор
    3.12. `ascii_visualizer.py` - ASCII Терминальный Визуализатор
    3.13. `analyzer.py` - Анализатор Данных Симуляции
    3.14. `code_verifier.py` - Инструмент Верификации Кода
    3.15. `project_schema.py` - Схема Структуры Проекта
4.  Начало Работы
    4.1. Предварительные Требования
    4.2. Установка и Настройка
    4.3. Запуск Симуляции
    4.4. Параметры Конфигурации
5.  Справочник Команд QikOS
6.  Разработка ИИ и Агентов
    6.1. Логика Принятия Решений Агента (`agent.py`)
    6.2. Интеграция с QikOS
    6.3. Перспективы Развития ИИ
7.  Руководство по Разработке
    7.1. Стандарты Кодирования
    7.2. Контроль Версий
    7.3. Тестирование
    7.4. Документирование Кода
8.  Глоссарий
9.  Приложения
    9.1. Детальные Спецификации Оборудования
    9.2. Детальный Список Сенсоров

---

## 1. Обзор Проекта

### 1.1. Введение
Проект QIKI (Quantum Intelligence Kinetic Interface) представляет собой разработку полнофункциональной автономной системы – программного симулятора космического автономного робота. Система нацелена на моделирование сложных взаимодействий между физическим миром, аппаратными компонентами робота и его интеллектуальной системой управления, основанной на ИИ и машинном обучении. Особое внимание уделяется модульности, расширяемости и возможности запуска симуляции на платформах с ограниченными ресурсами, таких как Termux на Android.

### 1.2. Цели и Задачи
Основные цели проекта QIKI:
*   **Создание модульной и расширяемой архитектуры:** Обеспечить легкость добавления новых компонентов и функциональности.
*   **Реалистичная симуляция:** Моделирование ключевых подсистем космического робота, включая физику, энергетику, терморегуляцию, структурную целостность и сенсорные системы.
*   **Интеграция продвинутого ИИ:** Внедрение ИИ-агентов, способных к автономному принятию решений и самообучению.
*   **Система управления задачами QikOS:** Реализация псевдо-ОС для управления внутренними процессами и командами робота.
*   **Визуализация и анализ:** Предоставление инструментов для отслеживания состояния симуляции и анализа собранных данных.
*   **Кроссплатформенность:** Обеспечение возможности запуска на различных системах, включая Android через Termux.

### 1.3. Ключевые Возможности
*   **Детализированная физическая модель:** Учет массы, инерции, сил, моментов и ориентации.
*   **Комплексная модель оборудования:** Моделирование работы каркаса, энергосистемы (солнечные панели, батареи) и системы терморегуляции.
*   **Многоуровневая сенсорная система:** Агрегация данных от различных виртуальных датчиков.
*   **Адаптивный ИИ-агент:** Способность принимать решения на основе текущей обстановки и состояния систем.
*   **Операционная система QikOS:** Управление задачами, командами и телеметрией.
*   **Два режима визуализации:** Графический дашборд на Matplotlib и текстовый ASCII-визуализатор.
*   **Система логирования и анализа:** Сбор данных о ходе симуляции и генерация отчетов.
*   **Конфигурируемость:** Гибкая настройка параметров симуляции через файл `config.py`.
*   **Инструменты верификации кода:** Поддержание качества и структуры кода с помощью `code_verifier.py` и `project_schema.py`.

---

## 2. Архитектура Системы

### 2.1. Высокоуровневая Архитектура
Система QIKI построена на модульном принципе, где каждый компонент отвечает за свою специфическую область.

*(Концептуальная диаграмма: [Основной цикл симуляции (main.py)] <-> [Физика (physics.py) + Среда (environment.py)] <-> [Оборудование (hardware/)] <-> [Сенсоры (sensors.py)] <-> [Агент ИИ (agent.py)] <-> [QikOS (qik_os.py)] -> [Визуализация/Анализ (visualizer.py, ascii_visualizer.py, analyzer.py)]. Все компоненты используют [Конфигурацию (config.py)] и [Логгер (logger.py)].)*

### 2.2. Обзор Основных Компонентов
*   **Ядро Симуляции (`main.py`):** Оркестрирует взаимодействие всех модулей, управляет основным циклом симуляции, временем и событиями.
*   **Физический Движок (`physics.py`):** Моделирует физику твердого тела, включая движение, вращение, применение сил и моментов.
*   **Среда (`environment.py`):** Определяет внешние условия, такие как гравитация, границы мира и солнечная иррадиация.
*   **Слой Аппаратной Абстракции (`hardware/`):**
    *   `frame_core.py`: Моделирует каркас робота, его массу и структурную целостность.
    *   `power_systems.py`: Моделирует генерацию (солнечные панели), хранение (батареи) и потребление энергии.
    *   `thermal_system.py`: Моделирует тепловые процессы, нагрев от компонентов и охлаждение через радиаторы.
*   **Сенсорная Система (`sensors.py`):** Агрегирует данные от всех "виртуальных" датчиков, связанных с физическим состоянием и состоянием аппаратных модулей.
*   **Агент ИИ (`agent.py`):** Принимает решения на основе данных от сенсоров и текущего состояния робота, управляет движением и ориентацией.
*   **QikOS (`qik_os.py`, `bot_interface_impl.py`):** Псевдо-операционная система для робота. Управляет задачами, выполняет команды, собирает телеметрию и предоставляет интерфейс (`BotInterface`) для взаимодействия с "железом" робота.
*   **Визуализация:**
    *   `visualizer.py`: Графический дашборд на основе Matplotlib для отображения 3D-траектории, состояния систем и других ключевых параметров.
    *   `ascii_visualizer.py`: Текстовый (ASCII) визуализатор для отображения информации в консоли, полезен для сред без графического интерфейса (например, Termux).
*   **Утилиты:**
    *   `logger.py`: Централизованная система логирования событий.
    *   `analyzer.py`: Сбор данных о ходе симуляции и генерация итоговых статистических отчетов.
    *   `config.py`: Хранилище всех глобальных конфигурационных параметров симуляции.
*   **Инструменты Верификации:**
    *   `code_verifier.py`: Утилита для статического анализа кода на соответствие архитектурным требованиям.
    *   `project_schema.py`: Определяет ожидаемую структуру проекта, зависимости и требования к компонентам.

### 2.3. Потоки Данных (Концептуально)
1.  **Инициализация:** `main.py` создает экземпляры всех компонентов, используя `config.py`.
2.  **Цикл симуляции (`main.py`):**
    *   `sensors.py` считывает данные из `physics.py` и `hardware/`.
    *   `agent.py` получает данные от `sensors.py` и `physics.py`, принимает решение.
    *   Команды от агента (или пользователя через QikOS) передаются в `physics.py` (применение сил/моментов).
    *   `qik_os.py` обрабатывает задачи, собирает телеметрию через `bot_interface_impl.py` (который обращается к `sensors.py`, `physics.py` и др.).
    *   `environment.py` применяет внешние силы к `physics.py`.
    *   `hardware/` модули обновляют свое состояние (например, разряд батареи в `power_systems.py` на основе `total_power_draw_w`).
    *   `physics.py` обновляет состояние робота (позиция, скорость, ориентация).
    *   `analyzer.py` логирует данные шага.
    *   `visualizer.py` и `ascii_visualizer.py` получают данные (в основном из `qik_os.telemetry_history` и `agent.target`) и обновляют отображение.
3.  **Логирование:** Все модули используют `logger.py` для записи событий.

---

## 3. Справочник по Модулям

### 3.1. `main.py` - Ядро Симуляции
*   **Назначение:** Главный файл приложения, отвечающий за инициализацию всех систем, управление основным циклом симуляции и корректное завершение работы.
*   **Класс: `QikiSimulation`**
    *   **Ответственность:**
        *   Инициализация всех компонентов: физического объекта, агента, сенсоров, среды, аппаратных модулей, QikOS, визуализаторов и анализатора.
        *   Управление основным циклом симуляции: пошаговое обновление состояния всех систем, обработка решений агента, выполнение задач QikOS.
        *   Обработка сигналов операционной системы (SIGINT, SIGTERM) для корректного завершения.
        *   Управление временем симуляции и синхронизация с реальным временем (если включено).
    *   **Ключевые Методы:**
        *   `__init__()`: Инициализирует все объекты и подсистемы. Рассчитывает начальную массу робота.
        *   `run()`: Запускает и управляет основным циклом симуляции. Включает чтение сенсоров, принятие решений агентом, обновление QikOS, обновление физики и аппаратных модулей, логирование и визуализацию.
        *   `shutdown()`: Инициирует процесс завершения симуляции, вызывая `cleanup()`.
        *   `cleanup()`: Выполняет необходимые действия по очистке перед выходом: финализация анализатора, закрытие визуализаторов, остановка QikOS, закрытие логгера.
        *   `handle_signal(signum, frame)`: Обработчик сигналов для безопасного прерывания симуляции.
*   **Основной Блок Выполнения (`if __name__ == "__main__":`)**
    *   Создает необходимые директории (`logs/`, `data/`).
    *   Инициализирует логгер.
    *   Создает экземпляр `QikiSimulation` и запускает симуляцию.
    *   Обеспечивает обработку глобальных исключений и корректный код завершения.

### 3.2. `config.py` - Конфигурация
*   **Назначение:** Централизованное хранилище всех статических конфигурационных параметров и констант, используемых в симуляции.
*   **Класс: `Config`**
    *   Содержит только атрибуты класса (статические поля).
    *   **Ключевые Группы Конфигурации:**
        *   **Физика:** `BOT_MASS` (начальная базовая масса), `GRAVITY`.
        *   **Время симуляции:** `TIME_STEP`, `MAX_TIME`, `REAL_TIME_MODE`.
        *   **Управление:** `THRUSTER_FORCE`, `TORQUE_MAX`.
        *   **Границы среды:** `BOUNDS`.
        *   **Визуализация:** `PLOT_HISTORY`, `UPDATE_RATE`, `ASCII_VISUALIZER_ENABLED`.
        *   **Безопасность и пороговые значения:** `MAX_VELOCITY`, `LOW_BATTERY_THRESHOLD`, `CRITICAL_INTEGRITY_THRESHOLD`, `OVERHEAT_THRESHOLD_C`, `STRESS_DAMAGE_THRESHOLD`, `TARGET_THRESHOLD` и др.
        *   **Энергетическая система:** Емкости батарей, параметры солнечных панелей, эффективности, пороги перегрузки, параметры энергопотребления различных компонентов.
        *   **Термальная система:** Начальные температуры, теплоемкость, коэффициент теплопередачи, температура космоса.
        *   **Каркас:** Базовая масса, пороги устойчивости к ускорениям.

### 3.3. `logger.py` - Система Логирования
*   **Назначение:** Предоставляет стандартизированный и централизованный механизм логирования для всего приложения.
*   **Класс: `Logger` (Синглтон)**
    *   **Ответственность:**
        *   Обеспечение единого экземпляра логгера для всего приложения.
        *   Настройка форматов логирования, уровней и обработчиков (вывод в консоль и файл).
        *   Создание файла лога с уникальной временной меткой для каждой сессии.
    *   **Ключевые Методы:**
        *   `get_logger(name=None)`: Статический метод для получения экземпляра логгера. Если указано `name`, возвращает дочерний логгер с именем `qiki.name`.
        *   `info(message)`, `debug(message)`, `warning(message)`, `error(message)`, `critical(message)`: Методы для логирования сообщений с соответствующими уровнями.
        *   `set_level(level)`: Устанавливает уровень логирования для основного логгера и его обработчиков.
        *   `close()`: Корректно закрывает файловые обработчики логгера. Вызывается при завершении работы приложения.

### 3.4. `physics.py` - Физический Движок
*   **Назначение:** Моделирование физических аспектов объектов в симуляции, включая их состояние (позиция, скорость, ориентация) и динамику (влияние сил и моментов).
*   **Класс: `State`**
    *   **Атрибуты:**
        *   `position` (np.ndarray): 3D вектор текущей позиции [x, y, z].
        *   `velocity` (np.ndarray): 3D вектор текущей линейной скорости [vx, vy, vz].
        *   `orientation` (np.ndarray): Кватернион [x, y, z, w], представляющий ориентацию.
        *   `angular_velocity` (np.ndarray): 3D вектор текущей угловой скорости [wx, wy, wz].
    *   **Назначение:** Инкапсулирует полное физическое состояние объекта в один момент времени.
*   **Класс: `PhysicsObject`**
    *   **Ответственность:**
        *   Представление физического объекта с массой и инерционными характеристиками.
        *   Отслеживание текущего состояния (`State`).
        *   Аккумулирование приложенных сил (`forces`) и моментов (`torques`).
        *   Обновление состояния на основе законов Ньютона (интегрирование движения).
    *   **Ключевые Методы:**
        *   `__init__(name, mass, initial_state)`: Инициализация объекта, расчет тензора инерции (упрощенный, для сферы).
        *   `apply_force(force_vector)`: Добавление вектора силы к объекту.
        *   `apply_torque(torque_vector)`: Добавление вектора момента к объекту.
        *   `update(dt)`: Обновляет позицию, скорость, ориентацию и угловую скорость на основе накопленных сил и моментов за временной шаг `dt`. Сбрасывает силы и моменты после обновления.
        *   `get_state()`: Возвращает копию текущего объекта `State`.
        *   `set_state(new_state)`: Устанавливает новое состояние объекта.
        *   `get_forward_vector()`: Рассчитывает и возвращает единичный вектор, направленный "вперед" относительно текущей ориентации объекта.
*   **Обработка Вращений:**
    *   Использует `scipy.spatial.transform.Rotation` для точной работы с кватернионами и вращениями, если библиотека доступна.
    *   В случае отсутствия `scipy`, используется класс-заглушка `DummyRotation`, который обеспечивает базовую совместимость API, но не выполняет реальных математических операций вращения. Это позволяет запускать симуляцию с ограниченной функциональностью вращений.

### 3.5. `hardware/` - Слой Аппаратной Абстракции
Модули в этой директории моделируют поведение различных аппаратных подсистем робота.

#### 3.5.1. `hardware/frame_core.py`
*   **Назначение:** Моделирование физического каркаса робота, его структурной целостности и связанных с этим датчиков.
*   **Класс: `StructuralSensors`**
    *   **Ответственность:** Имитация датчиков деформации, вибрации и общей целостности.
    *   **Ключевые Методы:**
        *   `update(current_acceleration, current_angular_acceleration)`: Обновляет показания на основе текущих линейных и угловых ускорений. Моделирует снижение целостности при превышении порогов стресса.
        *   `get_status()`: Возвращает словарь с текущими уровнями стресса, вибрации и процентом целостности.
*   **Класс: `FrameCore`**
    *   **Ответственность:** Представление основного каркаса, управление его базовой массой и общей структурной целостностью (которая синхронизируется с `StructuralSensors`).
    *   **Ключевые Методы:**
        *   `get_total_mass()`: Возвращает базовую массу каркаса.
        *   `update(current_acceleration, current_angular_acceleration)`: Обновляет состояние структурных датчиков.
        *   `get_status()`: Возвращает полный статус каркаса, включая данные от `StructuralSensors`.

#### 3.5.2. `hardware/power_systems.py`
*   **Назначение:** Моделирование энергетической системы робота, включая генерацию, хранение и потребление энергии.
*   **Класс: `PowerSensors`**
    *   **Ответственность:** Имитация датчиков, отслеживающих состояние батарей, генерацию солнечной энергии и текущее общее потребление.
    *   **Ключевые Методы:**
        *   `update(solar_power_generated_w, current_draw_w)`: Обновляет показания на основе данных от `PowerSystems`.
        *   `get_sensors_data()`: Возвращает словарь с текущими показаниями датчиков.
*   **Класс: `PowerSystems`**
    *   **Ответственность:** Управление зарядом основной и резервной батарей, расчет генерации энергии солнечными панелями, расчет общего энергопотребления и обновление состояния батарей.
    *   **Ключевые Методы:**
        *   `get_total_mass()`: Рассчитывает общую массу энергосистемы.
        *   `_calculate_power_demand()`: Рассчитывает текущее общее энергопотребление на основе `Config` (потребление в простое, сенсоров, связи и т.д.).
        *   `_generate_solar_power(solar_irradiance_w_per_m2)`: Рассчитывает генерацию энергии солнечными панелями.
        *   `consume_power(power_w, dt)`: Уменьшает заряд батарей на основе потребленной мощности.
        *   `update(solar_irradiance_w_per_m2, dt)`: Основной метод обновления: рассчитывает баланс энергии, заряжает или разряжает батареи.
        *   `get_status()`: Возвращает полный статус энергосистемы, включая проценты заряда, генерацию, потребление и текстовый статус (NOMINAL, OVERLOAD, LOW BATTERY).

#### 3.5.3. `hardware/thermal_system.py`
*   **Назначение:** Моделирование термальной системы робота, включая температуру ядра и радиаторов, а также теплообмен.
*   **Класс: `ThermalSystem`**
    *   **Ответственность:** Расчет изменения температур ядра и радиаторов на основе общей теплогенерации компонентов, теплообмена между ядром и радиаторами, и теплопотерь радиаторов в космос.
    *   **Ключевые Методы:**
        *   `update(dt, total_heat_generated_w)`: Обновляет температуры на основе законов теплопередачи и теплоемкости (заданных в `Config`).
        *   `_check_temperature_status()`: Обновляет текстовое сообщение о статусе (`status_message`) на основе порогов температур из `Config` (NOMINAL, OVERHEAT WARNING, CRITICAL OVERHEAT и т.д.).
        *   `get_status()`: Возвращает текущий статус термальной системы, включая температуры и `status_message`.

### 3.6. `environment.py` - Среда Симуляции
*   **Назначение:** Определение и управление параметрами окружающей среды, в которой находится робот.
*   **Класс: `Environment`**
    *   **Ответственность:**
        *   Применение глобальных сил, таких как гравитация.
        *   Обеспечение соблюдения границ симуляционного мира (эффект "отскока").
        *   Предоставление информации о среде, например, уровень солнечной иррадиации.
    *   **Ключевые Методы:**
        *   `apply_environmental_forces(physics_obj)`: Применяет гравитационную силу к объекту. Может включать и другие силы, например, сопротивление среды (если `air_drag_coefficient > 0`).
        *   `enforce_boundaries(physics_obj)`: Проверяет, не вышел ли объект за пределы, определенные в `Config.BOUNDS`. Если да, корректирует позицию и инвертирует соответствующую компоненту скорости с затуханием.
        *   `get_solar_irradiance(position)`: Возвращает текущую солнечную иррадиацию. В текущей реализации это константа из `Config`, но может быть расширена для учета положения.

### 3.7. `sensors.py` - Агрегация Данных Сенсоров
*   **Назначение:** Сбор и агрегация данных от всех виртуальных сенсоров робота, предоставляя единую точку доступа к сенсорной информации.
*   **Класс: `Sensors`**
    *   **Ответственность:**
        *   Взаимодействие с `PhysicsObject` и модулями из `hardware/` для получения "сырых" данных.
        *   Преобразование и структурирование этих данных в удобный формат.
        *   Проверка на критические состояния на основе порогов из `Config`.
    *   **Ключевые Методы:**
        *   `read_all(forces_applied)`: Основной метод, собирающий данные со всех подсистем и возвращающий их в виде словаря. `forces_applied` (последние примененные силы) может использоваться для более сложных моделей датчиков.
        *   `_read_navigation()`: Собирает навигационные данные (позиция, скорость, высота и т.д.) из `PhysicsObject`.
        *   `_read_frame_integrity()`: Собирает данные о состоянии каркаса из `FrameCore`.
        *   `_read_power()`: Собирает данные об энергосистеме из `PowerSystems`.
        *   `_read_thermal()`: Собирает данные о термальной системе из `ThermalSystem`.
        *   `check_critical_status(sensor_data)`: Анализирует собранные данные и возвращает словарь с флагами критических состояний (например, `low_battery`, `overheat`).

### 3.8. `agent.py` - Принятие Решений ИИ
*   **Назначение:** Реализация логики принятия решений для автономного управления роботом.
*   **Класс: `Agent`**
    *   **Ответственность:**
        *   Анализ текущего состояния робота (полученного от `PhysicsObject`) и данных от сенсоров (`Sensors`).
        *   Определение целевых управляющих воздействий (вектор тяги и вектор крутящего момента) для достижения поставленной цели (`self.target`).
        *   Реагирование на критические состояния систем (низкий заряд батареи, перегрев, повреждения каркаса) путем активации `emergency_stop` или снижения активности.
        *   Работа в автономном (`self.autonomous = True`) или ручном режиме.
    *   **Ключевые Методы:**
        *   `__init__()`: Инициализация агента, установка начальной цели и параметров (например, `decision_interval`).
        *   `decide(current_time, physics_obj, sensor_data)`: Основной метод принятия решений. Вызывается из главного цикла симуляции. Ограничивает частоту принятия решений.
        *   `set_target(new_target)`: Установка новой целевой позиции.
        *   `set_autonomous_mode(mode)`: Включение/выключение автономного режима.
        *   `_evaluate_overall_status(...)`: Оценивает общее состояние систем и определяет необходимость экстренных действий ("EMERGENCY_STOP", "REDUCE_ACTIVITY", "NONE").
        *   `_evaluate_temperature_status(...)`: Детальная оценка температурного статуса.
        *   `_navigate_to_target(...)`: Реализует базовую логику движения к цели и ориентации (эвристический подход, можно заменить на PID-регулятор). При достижении цели устанавливает новую случайную цель.
        *   `set_random_target()`: Устанавливает случайную цель в пределах `Config.BOUNDS`.
        *   `set_emergency_stop(status)`: Активирует/деактивирует режим аварийной остановки.
        *   `get_status()`: Возвращает словарь с текущим состоянием агента (цель, режим и т.д.).

### 3.9. `qik_os.py` - Операционная Система QIKI
*   **Назначение:** Реализация псевдо-операционной системы (QikOS) для управления задачами, командами и взаимодействием с "аппаратной" частью робота через стандартизированный интерфейс.
*   **Архитектура QikOS:**
    *   **`QikLogger`:** Специализированный логгер для компонентов QikOS.
    *   **`TaskState` (Enum):** Определяет возможные состояния задач (PENDING, RUNNING, COMPLETED, FAILED и т.д.).
    *   **`BotInterface` (Protocol):** Определяет контракт (методы), который должен реализовать объект, представляющий "бота", для взаимодействия с QikOS.
    *   **`TaskResult` (Dataclass):** Структура для хранения результата выполнения задачи.
    *   **`Task` (Dataclass):** Представление задачи с ID, именем команды, аргументами, приоритетом, состоянием, таймаутом и т.д. Реализует `__lt__` для использования в приоритетной очереди.
    *   **`TaskRegistry`:** Регистрирует и предоставляет обработчики для различных команд.
    *   **`QikOSKernel`:** Ядро QikOS, отвечает за асинхронное выполнение задач. Использует семафор для ограничения количества одновременно выполняемых задач. Обрабатывает таймауты и исключения.
    *   **`QikOSScheduler`:** Планировщик задач. Использует приоритетную очередь (`heapq`) для хранения и выдачи задач ядру. Позволяет добавлять и отменять задачи.
    *   **`QikOSShell`:** Оболочка для приема команд в виде строк, их парсинга и создания объектов `Task` для передачи в планировщик.
    *   **`QikiHandlers`:** Класс со статическими методами-обработчиками для стандартных команд QIKI (например, `qiki.sense.scan`, `qiki.move.thrust`). Эти обработчики взаимодействуют с `BotInterface` для выполнения действий на "боте".
*   **Класс: `QikOS` (Главный Orchestrator)**
    *   **Ответственность:** Объединяет и управляет всеми компонентами QikOS (ядром, планировщиком, оболочкой). Запускает и останавливает QikOS. Управляет основным циклом обработки задач. Собирает и хранит телеметрию.
    *   **Телеметрия (`_collect_telemetry`, `telemetry_history`):** Регулярно собирает данные о состоянии робота через `BotInterface` (позиция, скорость, заряд батареи, температура и т.д.) и сохраняет их в `self.telemetry_history` (словарь, где значения – это объекты `deque` ограниченной длины). Эти данные используются визуализаторами.
    *   **Обработка Задач (`process_tasks`):** Асинхронный метод, который в цикле извлекает задачи из планировщика и передает их на выполнение в ядро.

### 3.10. `bot_interface_impl.py` - Интерфейс Бота для QikOS
*   **Назначение:** Предоставляет конкретную реализацию протокола `BotInterface`, связывая абстрактные команды QikOS с реальными компонентами симуляции QIKI.
*   **Класс: `QikiBotInterface`**
    *   **Ответственность:** Реализация всех методов, определенных в протоколе `BotInterface`.
    *   **Взаимодействие:** При инициализации получает ссылки на все основные компоненты симуляции (`PhysicsObject`, `Sensors`, `Agent`, аппаратные модули, `Environment`, `QikiSimulation`).
    *   **Методы:**
        *   `get_sensor_data(sensor_type)`: Обращается к `Sensors.read_all()` для получения данных.
        *   `apply_movement(direction, magnitude)`: Обращается к `PhysicsObject.apply_force()` (после преобразования `direction` и `magnitude` в вектор силы).
        *   `get_system_info()`: Агрегирует информацию о состоянии от различных компонентов (физика, агент, энергосистема, термосистема, каркас, время симуляции).
        *   `get_current_simulation_time()`: Возвращает текущее время симуляции из экземпляра `QikiSimulation`.
        *   `set_agent_target(target_coords)`: Вызывает `Agent.set_target()`.
        *   `set_agent_autonomous_mode(mode)`: Вызывает `Agent.set_autonomous_mode()`.
        *   `update_simulation_time(current_sim_time)`: Позволяет `QikiSimulation` обновлять внутреннее время интерфейса.

### 3.11. `visualizer.py` - Графический Визуализатор
*   **Назначение:** Отображение состояния симуляции в графическом виде с использованием библиотеки Matplotlib.
*   **Класс: `Visualizer`**
    *   **Ответственность:**
        *   Создание и настройка окна Matplotlib с несколькими областями для графиков (3D-позиция, состояние энергосистемы, целостность, температура).
        *   Динамическое обновление графиков на основе данных телеметрии, получаемых от QikOS.
    *   **Ключевые Методы:**
        *   `__init__()`: Инициализация фигуры Matplotlib, осей и начальная настройка дашборда. Включает интерактивный режим (`plt.ion()`).
        *   `_setup_dashboard()`: Настройка заголовков, меток осей, пределов и легенд для всех графиков.
        *   `_initialize_plot_lines()`: Создание объектов `Line2D` и `Line3D` для всех отображаемых данных.
        *   `_update_dashboard(target_position)`: Обновляет данные на всех графиках. Извлекает данные из `self.telemetry_data` (переданного из `QikOS.telemetry_history`). Отображает позицию робота, траекторию, цель (3D), а также временные ряды для мощности, заряда батареи, целостности, уровня стресса и температур. Выполняет автомасштабирование осей.
        *   `update(telemetry_data, target_position)`: Основной метод обновления, вызываемый из `main.py`. Принимает актуальные данные телеметрии и позицию цели агента. Ограничивает частоту обновления согласно `Config.UPDATE_RATE`.
        *   `close()`: Закрывает окно Matplotlib.

### 3.12. `ascii_visualizer.py` - ASCII Терминальный Визуализатор
*   **Назначение:** Предоставление текстового (ASCII) интерфейса для мониторинга состояния симуляции в консоли. Особенно полезно для сред без графического интерфейса или для быстрого обзора.
*   **Ключевые Классы и Компоненты:**
    *   **`DisplayMode` (Enum):** Определяет режимы отображения (COMPACT, DETAILED, MINIMAL).
    *   **`VisualizationConfig` (Dataclass):** Хранит параметры конфигурации визуализатора (интервал обновления, ширина линии, режим отображения, использование цветов, длина прогресс-баров и т.д.).
    *   **`SystemMetrics` (Dataclass):** Структура для агрегированных и подготовленных к отображению метрик системы.
    *   **`ProgressBar`:** Утилитарный класс для генерации текстовых прогресс-баров.
    *   **`StatusIndicator`:** Утилитарный класс для форматирования значений с цветовыми индикаторами статуса (если терминал поддерживает цвета).
    *   **`LayoutManager`:** Управляет компоновкой (какие секции и в каком порядке отображать) для различных `DisplayMode`.
*   **Класс: `AsciiVisualizer`**
    *   **Ответственность:**
        *   Форматирование и вывод ключевых параметров симуляции в текстовом виде в консоль.
        *   Поддержка различных режимов детализации.
        *   Очистка экрана и обновление информации с заданной частотой.
        *   Автоматическое определение поддержки цветов в терминале.
    *   **Ключевые Методы:**
        *   `__init__(config)`: Инициализация, валидация конфигурации, определение поддержки цветов.
        *   `_clear_screen()`: Очищает экран консоли (использует ANSI-последовательности для эффективности, если поддерживается).
        *   `_should_update()`: Проверяет, нужно ли обновлять отображение на основе `config.update_interval`.
        *   `_extract_metrics(step, system_info, qikos_kernel_stats, qikos_scheduler_info)`: Извлекает данные из словарей, полученных от `main.py` (через `BotInterface`), и преобразует их в объект `SystemMetrics`. Выполняет валидацию входных данных.
        *   Методы рендеринга секций (`_render_header`, `_render_simulation_info`, `_render_bot_state`, `_render_core_systems`, `_render_qikos_status`, `_render_performance_info`): Форматируют отдельные блоки информации.
        *   `_render_display(metrics)`: Собирает полное отображение, вызывая методы рендеринга секций в соответствии с текущим макетом (`LayoutManager`).
        *   `update(step, system_info, qikos_kernel_stats, qikos_scheduler_info)`: Основной метод обновления. Вызывается из `main.py`. Использует `_update_lock.try_acquire()` для неблокирующего обновления. Реже проверяет размер терминала для оптимизации.
        *   `set_display_mode(mode)`, `set_update_interval(interval)`, `toggle_colors()`: Методы для изменения настроек визуализатора.
        *   `close()`: Корректное завершение работы, очистка экрана и вывод финальной статистики.
*   **Фабричные Функции:** `create_minimal_visualizer`, `create_compact_visualizer`, `create_detailed_visualizer` для удобного создания экземпляров с предопределенными конфигурациями.

### 3.13. `analyzer.py` - Анализатор Данных Симуляции
*   **Назначение:** Сбор, хранение и анализ данных, полученных в ходе сессии симуляции.
*   **Класс: `Analyzer`**
    *   **Ответственность:**
        *   Запись ключевых параметров состояния робота и среды на каждом шаге симуляции.
        *   Расчет итоговой статистики по завершении сессии.
        *   Сохранение всех собранных данных и статистики в JSON-файл.
    *   **Ключевые Методы:**
        *   `__init__(data_dir)`: Инициализация анализатора. Создает директорию для данных (если не существует) и файл сессии с уникальной временной меткой.
        *   `log_step(step, current_sim_time, physics_obj, sensors_data, agent_obj)`: Записывает данные текущего шага (позиция, скорость, состояние систем, статус агента и т.д.) в `self.session_data["steps"]`.
        *   `calculate_session_statistics()`: Рассчитывает различные статистические показатели за всю сессию: общее время симуляции, пройденное расстояние, максимальную/среднюю скорость, минимальный/средний заряд батареи, общее энергопотребление и т.д.
        *   `finalize()`: Вызывается при завершении симуляции. Записывает время окончания сессии, вызывает `calculate_session_statistics()` и сохраняет весь словарь `self.session_data` в JSON-файл.

### 3.14. `code_verifier.py` - Инструмент Верификации Кода
*   **Назначение:** Обеспечение соответствия кода проекта предопределенным архитектурным требованиям, стандартам качества и стилю.
*   **Класс: `EtalonniyCodeVerifier`**
    *   **Ответственность:**
        *   Статический анализ Python-файлов проекта.
        *   Проверка импортов, наличия ожидаемых классов и методов, корректного использования конфигурационных параметров (`Config`).
        *   Оценка качества кода: длина строк, цикломатическая сложность, покрытие кода документацией (docstrings).
        *   Генерация детальных отчетов о найденных проблемах.
    *   **Ключевые Возможности и Методы:**
        *   `__init__(project_root, config_file)`: Инициализация верификатора, загрузка конфигурации (шаблоны игнорирования, пороги для метрик).
        *   `_parse_python_file(filepath)`: Парсинг файла с использованием модуля `ast` для построения абстрактного синтаксического дерева и извлечения информации об импортах, классах, функциях, использовании `Config`.
        *   `_check_code_quality(...)`: Проверка длины строк, сложности, покрытия docstring.
        *   `_verify_imports(...)`, `_verify_components(...)`, `_verify_config_usage(...)`: Сравнение фактической структуры модуля с ожиданиями, определенными в `project_schema.py`.
        *   `verify_project()`: Основной метод, который обходит все Python-файлы в проекте (кроме игнорируемых), анализирует их и собирает все найденные проблемы.
        *   `print_detailed_report()`: Выводит подробный отчет о всех найденных проблемах, сгруппированных по файлам и уровням серьезности.
        *   `print_summary_report()`: Выводит краткий итоговый отчет и возвращает код выхода (0 - нет критических ошибок/ошибок, 1 - есть ошибки, 2 - есть критические ошибки).
        *   `save_report(filename)`: Сохраняет полный отчет в JSON-файл.
    *   **Использование `project_schema.py`:** Верификатор активно использует определения из `project_schema.py` (такие как `MODULE_REQUIREMENTS`, `CONFIG_USAGE_REQUIREMENTS`) в качестве "эталона" для сравнения.

### 3.15. `project_schema.py` - Схема Структуры Проекта
*   **Назначение:** Определение "контракта" или эталонной структуры для проекта QIKI. Этот файл используется `code_verifier.py` для проверки соответствия кода заданным архитектурным правилам.
*   **Ключевые Структуры Данных (Dataclasses):**
    *   **`ComponentType` (Enum):** Типы компонентов (CORE, HARDWARE, SENSOR и т.д.).
    *   **`ImportType` (Enum):** Типы импортов (STANDARD, THIRD_PARTY, LOCAL).
    *   **`ImportRequirement`:** Описывает ожидаемый импорт (модуль, тип, обязательность, псевдонимы).
    *   **`MethodRequirement`:** Описывает ожидаемый метод класса (имя, обязательность, параметры, тип возвращаемого значения, необходимость docstring, является ли `@classmethod`).
    *   **`ClassRequirement`:** Описывает ожидаемый класс (имя, список методов, обязательность, наследование, необходимость docstring).
    *   **`ModuleRequirement`:** Описывает ожидания для целого модуля (имя, тип компонента, список импортов, классов, функций, ожидаемое использование `Config`).
*   **Основные Словари-Схемы:**
    *   **`IMPORT_REQUIREMENTS`:** Словарь, где ключи – имена модулей, а значения – списки `ImportRequirement`.
    *   **`MODULE_REQUIREMENTS`:** Основной словарь, определяющий требования для каждого модуля проекта в виде объектов `ModuleRequirement`.
    *   **`CONFIG_USAGE_REQUIREMENTS`:** Словарь, определяющий, какие атрибуты `Config` должны использоваться в каждом модуле.
    *   **`ARCHITECTURE_RULES`:** Общие архитектурные правила (например, максимальная цикломатическая сложность, минимальное покрытие docstring).
    *   **`VALIDATION_EXCEPTIONS`:** Позволяет определять исключения из общих правил для конкретных модулей (например, разрешить более высокую сложность для `code_verifier.py`).
*   **Обратная совместимость:** Содержит также переменные `EXPECTED_IMPORTS`, `EXPECTED_COMPONENTS`, `EXPECTED_CONFIG_USAGE` для совместимости со старыми версиями верификатора, которые являются производными от новых детализированных схем.

---

## 4. Начало Работы

### 4.1. Предварительные Требования
*   **Python:** Версия 3.8 или выше.
*   **Основные Библиотеки:**
    *   `numpy`: Для научных вычислений и работы с массивами.
    *   `matplotlib`: Для графической визуализации.
    *   `scipy` (опционально, но рекомендуется): Для продвинутых математических операций, в частности, `scipy.spatial.transform.Rotation` для корректной работы с вращениями. Если `scipy` отсутствует, симуляция будет использовать упрощенную заглушку для вращений.
*   **Для запуска в Termux (Android):**
    *   Установленный Termux.
    *   Установленный Python и pip в Termux.
    *   Установка библиотек:
        ```bash
        pkg install python python-numpy python-matplotlib
        # scipy может потребовать дополнительных шагов для установки в Termux
        # pip install scipy 
        ```

### 4.2. Установка и Настройка
1.  **Клонируйте или скачайте репозиторий проекта.**
    ```bash
    # git clone <repository_url>
    # cd qiki_simulation 
    ```
    (Если это локальный проект, просто перейдите в корневую директорию проекта).
2.  **Установите зависимости (если используется `requirements.txt`):**
    ```bash
    pip install -r requirements.txt 
    ```
    Если файла `requirements.txt` нет, установите библиотеки вручную:
    ```bash
    pip install numpy matplotlib scipy
    ```
3.  **Создайте необходимые директории:**
    Скрипт `main.py` автоматически создает директории `logs/` и `data/` при запуске, если они отсутствуют.

### 4.3. Запуск Симуляции
Для запуска симуляции выполните команду из корневой директории проекта:
```bash
python main.py
Если Config.REAL_TIME_MODE = False (по умолчанию), симуляция будет работать так быстро, как позволяет производительность системы.
Если Config.REAL_TIME_MODE = True, симуляция будет пытаться синхронизироваться с реальным временем, делая паузы между шагами.
Если Config.ASCII_VISUALIZER_ENABLED = True (по умолчанию), в консоли будет отображаться ASCII-дашборд.
Если Config.REAL_TIME_MODE = False и Matplotlib доступен, запустится графический визуализатор.
Для остановки симуляции нажмите Ctrl+C в терминале.

4.4. Параметры Конфигурации
Все основные параметры симуляции настраиваются в файле config.py. См. раздел 3.2 для описания ключевых параметров. Изменение этих параметров позволяет адаптировать симуляцию под различные сценарии и условия.

5. Справочник Команд QikOS
QikOS позволяет управлять роботом и его системами через текстовые команды. Команды могут быть отправлены через QikOSShell.submit_command().

Ниже приведен список стандартных команд, реализованных в QikiHandlers:

qiki.sense.scan <area_name> [resolution_level]

Назначение: Инициирует сканирование указанной области.
Аргументы:
area_name (str): Имя или идентификатор области для сканирования.
resolution_level (str, опционально): Уровень разрешения сканирования (например, "high", "medium", "low"). По умолчанию "high".
Возвращает (в TaskResult.data): Словарь с информацией о результатах сканирования, например, количество найденных точек, качество, временная метка.
Пример: qiki.sense.scan sector_alpha high
qiki.move.thrust <direction> <magnitude>

Назначение: Применяет тягу к роботу.
Аргументы:
direction (str): Направление тяги. Может быть предопределенным ("forward", "backward") или вектором в виде строки "x,y,z" (например, "1,0,0").
magnitude (float): Величина тяги в Ньютонах.
Возвращает: Словарь со статусом применения команды.
Пример: qiki.move.thrust forward 100.0 или qiki.move.thrust 0,1,0 50.0
qiki.mem.info

Назначение: Запрашивает информацию о состоянии памяти (заглушка в текущей реализации).
Аргументы: Нет.
Возвращает: Словарь с информацией о памяти (общая, использованная, свободная).
Пример: qiki.mem.info
qiki.sys.status [component_name]

Назначение: Запрашивает статус системы или конкретного компонента (заглушка в текущей реализации).
Аргументы:
component_name (str, опционально): Имя компонента. Если не указано, возвращается общий статус.
Возвращает: Словарь со статусом, временем работы, версией QikOS.
Пример: qiki.sys.status kernel или qiki.sys.status
qiki.agent.set_target <x> <y> <z>

Назначение: Устанавливает новую целевую позицию для ИИ-агента.
Аргументы:
x (float): Координата X цели.
y (float): Координата Y цели.
z (float): Координата Z цели.
Возвращает: Словарь со статусом установки цели.
Пример: qiki.agent.set_target 50.0 25.0 10.0
qiki.agent.set_mode <autonomous|manual>

Назначение: Устанавливает режим работы ИИ-агента.
Аргументы:
mode (str): "autonomous" для автономного режима, "manual" для ручного.
Возвращает: Словарь со статусом установки режима.
Пример: qiki.agent.set_mode autonomous
Новые команды могут быть добавлены путем регистрации новых обработчиков в TaskRegistry ядра QikOS.

6. Разработка ИИ и Агентов
6.1. Логика Принятия Решений Агента (agent.py)
Текущая реализация ИИ-агента в agent.py основана на процедурной логике:

Ограничение частоты решений: Агент принимает решения с интервалом, заданным Config.AGENT_DECISION_INTERVAL.
Сбор данных: Агент получает текущую позицию, скорость и ориентацию от PhysicsObject, а также агрегированные данные от Sensors (целостность, заряд батареи, температура, уровень стресса).
Оценка общего состояния (_evaluate_overall_status):
Проверяется целостность каркаса (Config.CRITICAL_INTEGRITY_THRESHOLD).
Проверяется общий заряд батарей (Config.LOW_BATTERY_THRESHOLD).
Вызывается _evaluate_temperature_status для оценки температурного режима.
Проверяется уровень структурного стресса (Config.STRESS_DAMAGE_THRESHOLD).
На основе этих проверок возвращается статус ("CRITICAL_INTEGRITY", "LOW_BATTERY", "OVERHEAT_CRITICAL", "HIGH_STRESS", "NOMINAL") и требуемое действие ("EMERGENCY_STOP", "REDUCE_ACTIVITY", "NONE").
Экстренные действия: Если требуется "EMERGENCY_STOP", агент активирует self.emergency_stop. Если "REDUCE_ACTIVITY", агент временно прекращает активные действия (возвращает нулевые тягу и момент).
Навигация к цели (_navigate_to_target):
Если нет критических состояний, агент рассчитывает вектор тяги и крутящего момента для движения к self.target.
Тяга: Направлена к цели. Величина зависит от расстояния до цели и текущей скорости по направлению к цели (простое демпфирование для предотвращения "перелета").
Крутящий момент: Если текущее направление "вперед" робота значительно отклоняется от направления на цель, рассчитывается крутящий момент для коррекции ориентации. Ось вращения определяется векторным произведением, величина момента зависит от угла рассогласования.
Достижение цели: Если расстояние до цели меньше Config.TARGET_THRESHOLD, цель считается достигнутой, устанавливается новая случайная цель, и агент пытается остановить робота.
Установка случайной цели (set_random_target): Генерирует новую случайную цель в пределах, определенных Config.BOUNDS.
6.2. Интеграция с QikOS
Агент напрямую не интегрирован с системой задач QikOS в текущей реализации main.py (т.е. его метод decide() вызывается напрямую из основного цикла). Однако, QikOS может влиять на агента и получать от него информацию через BotInterface:

Команды QikOS для агента:
qiki.agent.set_target: Позволяет через QikOS установить новую цель для агента.
qiki.agent.set_mode: Позволяет через QikOS переключить автономный/ручной режим агента.
Получение статуса агента: BotInterface.get_system_info() включает вызов Agent.get_status(), что делает информацию о состоянии агента доступной для QikOS (например, для телеметрии или других задач).
6.3. Перспективы Развития ИИ
Текущий агент является базовым. Документы "ai mech.txt", "Метод Разработки.txt" и аналитические файлы ("Анализ 2.txt", "Анализ3.txt") описывают значительно более сложные подходы к разработке ИИ, которые могут быть реализованы в будущем:

Специализированные агенты: Вместо одного монолитного агента, создание иерархии агентов, каждый из которых отвечает за свою подсистему (например, IntelligentPowerAgent, IntelligentThermalAgent, NavigationAgent), как описано в "ai mech.txt" и "Метод Разработки.txt".
Нейронные сети: Использование нейронных сетей для принятия решений. "ai mech.txt" предоставляет базовую реализацию NeuralNetwork, а "Метод Разработки.txt" описывает принципы ее построения (модульность, функции активации, инициализация весов). Рекомендуется использовать фреймворки, такие как TensorFlow/Keras или PyTorch.
Обучение с подкреплением (Reinforcement Learning - RL):
Применение Q-Learning (базовая реализация QLearningAgent в "ai mech.txt").
Использование библиотек, таких как Gym (для создания сред обучения) и Stable Baselines3 (для готовых RL-алгоритмов, таких как DQN, PPO).
Разработка системы вознаграждений (RewardSystem в "Метод Разработки.txt") для обучения агентов достижению целей и избеганию нежелательных состояний.
Оптимизация для ограниченных ресурсов (Termux):
Применение техник, таких как квантизация весов и прунинг нейронов.
Использование легковесных версий фреймворков (TensorFlow Lite, PyTorch Mobile) или формата ONNX для развертывания моделей.
Улучшенное тестирование и валидация: Автоматизированные тесты для проверки консистентности решений агентов, сходимости обучения и интеграции между агентами.
Координация агентов: Разработка AgentManager для управления и координации действий нескольких агентов.
7. Руководство по Разработке
7.1. Стандарты Кодирования
PEP 8: Следуйте официальному руководству по стилю Python PEP 8.
Типизация: Используйте аннотации типов (Python type hints) для улучшения читаемости и статического анализа. Проект использует typing для этого.
Docstrings: Все публичные модули, классы и функции должны иметь содержательные docstrings в стиле Google или NumPy.
Комментарии: Используйте комментарии для объяснения сложной или неочевидной логики.
Верификация кода: Регулярно используйте code_verifier.py для проверки соответствия кода project_schema.py и общим стандартам качества.
7.2. Контроль Версий
Git: Используйте систему контроля версий Git для всех изменений в коде.
Ветки: Ведите разработку новой функциональности в отдельных ветках (feature branches).
Коммиты: Делайте атомарные, хорошо описанные коммиты.
Слияние: Используйте pull requests (или merge requests) для ревью кода перед слиянием в основную ветку.
7.3. Тестирование
Модульное тестирование (Unit Tests): Каждый модуль и класс должен иметь набор unit-тестов, проверяющих его функциональность в изоляции. Рекомендуется использовать unittest или pytest.
Интеграционное тестирование: Тестируйте взаимодействие между различными компонентами системы.
Сценарное тестирование: Создавайте тестовые сценарии для проверки поведения системы в различных ситуациях, включая граничные и нештатные.
Автоматизация: Автоматизируйте запуск тестов (например, с помощью CI/CD инструментов, если применимо).
7.4. Документирование Кода
Docstrings: Как указано выше, документируйте все публичные API.
README.md: Поддерживайте актуальный README.md файл в корне проекта с описанием проекта, инструкциями по установке и запуску.
Техническая документация: Данный документ является примером технической документации. Поддерживайте его в актуальном состоянии при внесении значительных изменений в архитектуру или функциональность.
Журнал разработки (journal.md): Как указано в "Техзадание.txt", рекомендуется вести журнал разработки для отслеживания ключевых решений, проблем и прогресса.
8. Глоссарий
QIKI (Quantum Intelligence Kinetic Interface): Название проекта и симулируемой автономной системы.
Агент (Agent): Программный компонент, отвечающий за принятие решений и управление роботом или его подсистемами.
QikOS: Псевдо-операционная система для робота QIKI, управляющая задачами и командами.
Состояние (State): Набор параметров, описывающих физическое положение, скорость и ориентацию объекта.
Телеметрия (Telemetry): Данные о состоянии систем робота, собираемые и передаваемые для мониторинга или анализа.
Иррадиация (Irradiance): Мощность солнечного излучения на единицу площади.
Кватернион (Quaternion): Математический объект, используемый для представления ориентации или вращения в 3D-пространстве.
Тензор инерции (Inertia Tensor): Физическая величина, описывающая распределение массы тела и его сопротивление угловому ускорению.
Deque (Double-ended queue): Коллекция, позволяющая эффективно добавлять и удалять элементы с обоих концов; используется для хранения истории телеметрии.
AST (Abstract Syntax Tree): Древовидное представление структуры кода, используемое code_verifier.py для анализа.
9. Приложения
9.1. Детальные Спецификации Оборудования
(Этот раздел должен быть основан на "Струкрутнаясхема.txt". Приведен краткий пересказ ключевых моментов. Для полной информации см. исходный файл.)

Физическая структура:
Корпус из алюминиевого сплава, разделенный на сенсорную, вычислительную и двигательную секции.
Боковые панели-радиаторы.
Многослойная защита (микрометеоритная, радиационная, тепловая).
Энергетическая система:
Солнечные панели: 3 шт. (2 складные по 500Вт, 1 неподвижная 200Вт), общая макс. генерация ~1200Вт.
Батареи: Основная (Li-ion, 100Ач), резервная (Li-ion, 50Ач), буферные суперконденсаторы. Система управления BMS.
Распределение: Главная шина 24В, DC-DC преобразователи (12В, 5В, 3.3В), инвертор 220В.
Двигательная установка:
Основные двигатели: 4 ион-плазменных двигателя.
Маневровые двигатели: 3 блока RCS (азот).
Система подачи топлива: Баки для ксенона и азота.
Система терморегуляции:
Активное охлаждение: Радиаторы, тепловые трубы, циркуляционные насосы.
Пассивное охлаждение: Теплопроводящие пластины, излучающие поверхности.
Нагревательные элементы для критически важных компонентов.
Вычислительное ядро:
Центральный процессор: ARM Cortex (основной + резервный), GPU, NPU.
Память: DDR4 RAM (основная + резервная), SSD (основной + резервный), EEPROM.
Специализированные процессоры: DSP, FPGA, MCU.
Система связи:
Основная связь: Антенны X, S, UHF диапазонов.
Резервная связь: Омни-антенна, аварийный маяк, лазерная связь.
Межспутниковая связь (Crosslink).
9.2. Детальный Список Сенсоров
(Этот раздел основан на "датчики.txt". Приведены основные категории. Для полной информации см. исходный файл.)

Центральная сенсорная система (sensors.py):
RLSM-Комплекс: Радар, Лидар, Спектрометр, Магнитометр.
Навигационные датчики: Звездный трекер, Гироскопы, Акселерометры, IMU.
Датчики приближения: Для стыковки, избегания столкновений, лазерные дальномеры.
Датчики окружающей среды (опционально): Радиационные мониторы, детекторы микрометеоритов, анализаторы плазмы.
Датчики двигательной системы (propulsion.py): Мониторы вектора тяги, расходомеры топлива, термопары сопел, энкодеры подвеса.
Энергетический мониторинг (power_systems.py): Датчики BMS, датчики солнечных панелей, мониторы шины питания, датчики тока.
Термальные датчики (thermal.py): Мониторы температуры ядра, датчики температуры радиаторов, датчики потока в тепловых трубах, ИК-камеры.
Коммуникационные датчики (communication.py): Измерители уровня сигнала, датчики выравнивания антенн, анализаторы частот, мониторы качества данных.
Датчики РЭБ (опционально): Детекторы помех, приемники перехвата сигналов.
Структурные датчики (frame_core.py): Тензодатчики (деформация), датчики вибрации, датчики давления корпуса.
Системные датчики (nexus_core.py): Мониторы шины данных, мониторы состояния процессоров, датчики целостности памяти.